<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Izumi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-05T08:30:43.519Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>IzumiSakai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-cloud</title>
    <link href="http://yoursite.com/2019/03/05/spring-cloud/"/>
    <id>http://yoursite.com/2019/03/05/spring-cloud/</id>
    <published>2019-03-05T05:49:22.000Z</published>
    <updated>2019-03-05T08:30:43.519Z</updated>
    
    <content type="html"><![CDATA[<h5 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud:"></a>spring cloud:</h5><p>​    Spring Cloud Netflix:</p><p>​        是对Netflix开发的一套分布式服务器框架封装，包括服务的发现和注册，负载均衡，断路器，REST客户端，请求路由等。</p><p>​    Spring Cloud Eureka:</p><p>​        是Spring Colud Netflix为服务套件中的一部分，基于Netflix Eureka做了二次封装，主要负责完成微服务架构中的服务治理功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>eureka服务端</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// eureka 服务端</span></span><br><span class="line"><span class="meta">@EnableFeignClien</span>  <span class="comment">//开启feign客户端</span></span><br></pre></td></tr></table></figure><p>服务提供者</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;spring-cloud&quot;&gt;&lt;a href=&quot;#spring-cloud&quot; class=&quot;headerlink&quot; title=&quot;spring cloud:&quot;&gt;&lt;/a&gt;spring cloud:&lt;/h5&gt;&lt;p&gt;​    Spring Cloud Netflix:&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="spring cloud" scheme="http://yoursite.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>jdk11新特性</title>
    <link href="http://yoursite.com/2019/03/05/jdk11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/05/jdk11新特性/</id>
    <published>2019-03-05T03:48:21.000Z</published>
    <updated>2019-03-05T03:48:21.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jdk8新特性</title>
    <link href="http://yoursite.com/2019/03/05/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/03/05/jdk8新特性/</id>
    <published>2019-03-05T03:26:30.000Z</published>
    <updated>2019-03-05T03:55:25.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jdk8新特性"><a href="#jdk8新特性" class="headerlink" title="jdk8新特性"></a>jdk8新特性</h3><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>Lambda表达式用于表示一个函数，所以它和函数一样，也拥有参数、返回值、函数体，但它没有函数名，所以Lambda表达式相当于一个匿名函数。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Person person)—&gt;person.getAge()&gt;<span class="number">30</span></span><br></pre></td></tr></table></figure><p>Lambda表达式用—&gt;连接，-&gt;左侧为函数的参数，-&gt;右侧为函数体。<br>若右侧由多条语句构成则需要用{}包裹</p><h6 id="为lambda表达式定义函数式接口"><a href="#为lambda表达式定义函数式接口" class="headerlink" title="为lambda表达式定义函数式接口"></a>为lambda表达式定义函数式接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FilterProcessor</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现筛选函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, FilterProcessor&lt;T&gt; filterProcessor)</span></span>&#123;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span>(filterProcessor.process(t))</span><br><span class="line">        result.add(t);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><h4 id="optional类"><a href="#optional类" class="headerlink" title="optional类"></a>optional类</h4><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>Java 8 新增了接口的默认方法</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法</p><p>只需要在方法名前面加个default关键字即可实现默认方法</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Vehicle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">defalut <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个默认方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="super调用指定接口的默认方法"><a href="#super调用指定接口的默认方法" class="headerlink" title="super调用指定接口的默认方法"></a>super调用指定接口的默认方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>, <span class="title">FourWheeler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Vehicle.<span class="keyword">super</span>.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态默认方法"><a href="#静态默认方法" class="headerlink" title="静态默认方法"></a>静态默认方法</h5><p>java8的另一个特性是接口可以声明（并且可以提供实现）静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"我是一辆车!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blowHorn</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"按喇叭!!!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新的日期时间API"><a href="#新的日期时间API" class="headerlink" title="新的日期时间API"></a>新的日期时间API</h4><h5 id="本地化日期时间API"><a href="#本地化日期时间API" class="headerlink" title="本地化日期时间API"></a>本地化日期时间API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">Month month = currentTime.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = currentTime.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> seconds = currentTime.getSecond();</span><br><span class="line"><span class="comment">//date2: 2012-04-10T16:55:48.668</span></span><br><span class="line">LocalDate date2 = currentTime.withDayOfMonth(<span class="number">10</span>).withYear(<span class="number">2012</span>);</span><br><span class="line"><span class="comment">//date3: 2014-12-12</span></span><br><span class="line">LocalDate date3 = LocalDate.of(<span class="number">2014</span>,Month.DECEMBER,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//date4: 22:15</span></span><br><span class="line">LocalTime date4 = localTime.of(<span class="number">22</span>,<span class="number">15</span>);</span><br><span class="line"><span class="comment">//date5: 20:15:30  解析字符串</span></span><br><span class="line">LocalTime date5 = LocalTime.parse(<span class="string">"20:15:30"</span>)</span><br></pre></td></tr></table></figure><h5 id="使用时区的日期时间API"><a href="#使用时区的日期时间API" class="headerlink" title="使用时区的日期时间API"></a>使用时区的日期时间API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间日期</span></span><br><span class="line">ZonedDateTime date1 = ZonedDateTime。parse(<span class="string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ZoneId : Europe/Paris</span></span><br><span class="line">ZoneId id = ZoneId.of(<span class="string">"Europe/Paris"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前失去 ： Asia/Shanghai</span></span><br><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jdk8新特性&quot;&gt;&lt;a href=&quot;#jdk8新特性&quot; class=&quot;headerlink&quot; title=&quot;jdk8新特性&quot;&gt;&lt;/a&gt;jdk8新特性&lt;/h3&gt;&lt;h4 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://yoursite.com/2019/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/03/04/面试题/</id>
    <published>2019-03-04T11:04:48.000Z</published>
    <updated>2019-03-07T08:05:43.621Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>String和String Buffer以及String Builer的区别</p><p>线程安全：String和StringBuilder线程不安全，StringBuffer线程安全</p><p>效率：StringBuilder &gt; StringBuffcer</p><p>使用原则：当数据量小且单线程使用String，数据量大单线程使用StringBuilder。多线程使用StringBuffer</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;String和String Buffer以及String Builer的区别&lt;/p&gt;
&lt;p&gt;线程安全：String和StringBuilder线程不安全，StringBuffer线程安全&lt;/p&gt;
&lt;p&gt;效率：StringBuilder &amp;gt; Strin
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理</title>
    <link href="http://yoursite.com/2019/03/04/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/04/HashMap实现原理/</id>
    <published>2019-03-04T10:59:44.000Z</published>
    <updated>2019-03-05T05:51:10.447Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HashMap实现原理："><a href="#HashMap实现原理：" class="headerlink" title="HashMap实现原理："></a>HashMap实现原理：</h4><h6 id="jdk1-8以前"><a href="#jdk1-8以前" class="headerlink" title="jdk1.8以前"></a>jdk1.8以前</h6><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>哈希表（散列表）：在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)；哈希表的主干是数组；</p><h5 id="哈希冲突："><a href="#哈希冲突：" class="headerlink" title="哈希冲突："></a>哈希冲突：</h5><p>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式</p><p>HashMap的主干是一个Entry数组，Entry是Hash Map的基本组成单元，每一个Entry包含一个key-value键值对。</p><p>Entry是HashMap中的一个静态内部类。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">        <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="HashMap整体结构"></p><h5 id="其他几个重要字段"><a href="#其他几个重要字段" class="headerlink" title="其他几个重要字段"></a>其他几个重要字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际存储的key-value键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子，代表了table的填充度有多少，默认是0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h5 id="jdk1-8之后"><a href="#jdk1-8之后" class="headerlink" title="jdk1.8之后"></a>jdk1.8之后</h5><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树是一种平衡二叉树，为了解决二叉树的缺陷，因为二叉树查找某些情况下会退化成为一个线性结构</p><h6 id="为什么不直接使用红黑树"><a href="#为什么不直接使用红黑树" class="headerlink" title="为什么不直接使用红黑树"></a>为什么不直接使用红黑树</h6><p>我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡。引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。</p><h6 id="HashMap构造器"><a href="#HashMap构造器" class="headerlink" title="HashMap构造器"></a>HashMap构造器</h6><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>数据结构的物理存储结构只有两种：顺序存储和链式存储。    </p><h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     * static final float DEFAULT_LOAD_FACTOR = 0.75f; 装填因子，在数组长度的0.75的时候扩容</span></span><br><span class="line"><span class="comment">     * final float loadFactor 接收装填因子的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="HashMap和HashTable的区别-HashSet和HashMap的区别"><a href="#HashMap和HashTable的区别-HashSet和HashMap的区别" class="headerlink" title="HashMap和HashTable的区别/HashSet和HashMap的区别"></a>HashMap和HashTable的区别/HashSet和HashMap的区别</h5><h6 id="Hash-Map和HashTable"><a href="#Hash-Map和HashTable" class="headerlink" title="Hash Map和HashTable"></a>Hash Map和HashTable</h6><ol><li>线程安全：HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法都通过synchronized修饰（如果要保证线程安全使用ConcurrentHashMap）</li><li>效率：HashMap效率高，因为HashTable需要保证线程安全</li><li>对Null Key和Null Value 的支持：HashMap中,null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为Null，HashTable只要有一个键为Null，就抛出空指针异常</li><li>①初始容量大小和每次扩容增量不同：HashTable默认为11，每次扩容变为 原来的2n+1，HashMap默认初始化大小为16，之后每次扩容容量变为原来的2倍。②如果创建的时候给定了初始容量值，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tableSizeFor（）方法保证），也就是说Hash Map总是使用2的幂次方作为哈希表的大小。</li><li>底层数据结构：红黑树和链表散列的区别</li></ol><h6 id="HashSet和HashMap"><a href="#HashSet和HashMap" class="headerlink" title="HashSet和HashMap"></a>HashSet和HashMap</h6><p>如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。）</p><table><thead><tr><th style="text-align:center">HashMap</th><th style="text-align:center">HashSet</th></tr></thead><tbody><tr><td style="text-align:center">实现了Map接口</td><td style="text-align:center">实现Set接口</td></tr><tr><td style="text-align:center">存储键值对</td><td style="text-align:center">仅存储对象</td></tr><tr><td style="text-align:center">调用put()向map中添加元素</td><td style="text-align:center">调用add()方法向Set中添加元素</td></tr><tr><td style="text-align:center">HashMap使用key计算HashCode</td><td style="text-align:center">HashSet使用成员对象来计算HashCode，<br>对于两个对象来说hashCode可能相同，<br>所以equals()方法来判断对象的相等性，<br>如果两个对象不相同的话，返回false</td></tr><tr><td style="text-align:center">HashMap相对于HashSet来说较快，因为它使用唯一的键获取对象</td><td style="text-align:center">较慢</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HashMap实现原理：&quot;&gt;&lt;a href=&quot;#HashMap实现原理：&quot; class=&quot;headerlink&quot; title=&quot;HashMap实现原理：&quot;&gt;&lt;/a&gt;HashMap实现原理：&lt;/h4&gt;&lt;h6 id=&quot;jdk1-8以前&quot;&gt;&lt;a href=&quot;#jdk1-
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
