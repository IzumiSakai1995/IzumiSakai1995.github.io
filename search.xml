<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot整合篇]]></title>
    <url>%2F2019%2F03%2F20%2Fspringboot%E6%95%B4%E5%90%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[mybatis引入依赖在 pom.xml 文件中引入 druid-spring-boot-starter 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 引入数据库连接依赖 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置application.yml123456789101112spring: datasource: druid: url: jdbc:mysql://ip:port/dbname?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true # MySQL 8.x: com.mysql.cj.jdbc.Driver driver-class-name: com.mysql.jdbc.Driver 配置tk.mybatistk.mybatis 是在 MyBatis 框架的基础上提供了很多工具，让开发更加高效 引入依赖在 pom.xml 文件中引入 mapper-spring-boot-starter 依赖，该依赖会自动引入 MyBaits 相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 配置application.yml123mybatis: type-aliases-package: 实体类的存放路径，如：com.funtl.hello.spring.boot.entity mapper-locations: classpath:mapper/*.xml 创建一个通用的父级接口1234567891011121314151617package com.funtl.utils;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * &lt;p&gt;Title: MyMapper&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; 整合PageHelperPageHelper 是 Mybatis 的分页插件，支持多数据库、多数据源。可以简化数据库的分页查询操作，整合过程也极其简单，只需引入依赖即可。 引入依赖在 pom.xml 文件中引入 pagehelper-spring-boot-starter 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 使用 MyBatis 的 Maven 插件生成代码我们无需手动编写 实体类、DAO、XML 配置文件，只需要使用 MyBatis 提供的一个 Maven 插件就可以自动生成所需的各种文件便能够满足基本的业务需求，如果业务比较复杂只需要修改相关文件即可。 配置插件在 pom.xml 文件中增加 mybatis-generator-maven-plugin 插件 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; configurationFile：自动生成所需的配置文件路径 自动生成的配置在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 引入数据库连接配置 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;context id="Mysql" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- 配置 tk.mybatis 插件 --&gt; &lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;property name="mappers" value="com.funtl.utils.MyMapper"/&gt; &lt;/plugin&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driverClass&#125;" connectionURL="$&#123;jdbc.connectionURL&#125;" userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置实体类存放路径 --&gt; &lt;javaModelGenerator targetPackage="com.funtl.hello.spring.boot.entity" targetProject="src/main/java"/&gt; &lt;!-- 配置 XML 存放路径 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/&gt; &lt;!-- 配置 DAO 存放路径 --&gt; &lt;javaClientGenerator targetPackage="com.funtl.hello.spring.boot.mapper" targetProject="src/main/java" type="XMLMAPPER"/&gt; &lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt; &lt;table catalog="myshop" tableName="%"&gt; &lt;!-- mysql 配置 --&gt; &lt;generatedKey column="id" sqlStatement="Mysql" identity="true"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置数据源在 src/main/resources 目录下创建 jdbc.properties 数据源配置： 12345# MySQL 8.x: com.mysql.cj.jdbc.Driverjdbc.driverClass=com.mysql.jdbc.Driverjdbc.connectionURL=jdbc:mysql://ip:port/dbname?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 插件自动生成命令1mvn mybatis-generator:generate 完整配置案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN""http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用$&#123;propertyKey&#125;的方式来引用配置项 resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties. 注意，两个属性只能选址一个; 另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource="" url="" /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包 location属性指明加载jar/zip包的全路径&lt;classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip" /&gt; --&gt; &lt;!-- context:生成一组对象的环境 id:必选，上下文id，用于在生成错误时提示 defaultModelType:指定生成对象的样式 1，conditional：类似hierarchical； 2，flat：所有内容（主键，blob）等全部生成在一个对象中； 3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class) targetRuntime: 1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample； 2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample； introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id="mysql" defaultModelType="hierarchical" targetRuntime="MyBatis3Simple" &gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name="autoDelimitKeywords" value="false"/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter"/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter"/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- 必须要有的，使用这个配置链接数据库 @TODO:是否可以扩展 # MySQL 8.x: com.mysql.cj.jdbc.Driver --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql:///pss" userId="root" password="admin"&gt; &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type="org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- java模型创建器，是必须要的元素 负责：1，key类（见context的defaultModelType）；2，java类；3，查询类 targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage="com._520it.mybatis.domain" targetProject="src/main/java"&gt; &lt;!-- for MyBatis3/MyBatis3Simple 自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter； --&gt; &lt;property name="constructorBased" value="false"/&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- for MyBatis3 / MyBatis3Simple 是否创建一个不可变的类，如果为true， 那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --&gt; &lt;property name="rootClass" value="com._520it.mybatis.domain.BaseDomain"/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成SQL map的XML文件生成器， 注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口）， 或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置 targetPackage/targetProject:同javaModelGenerator --&gt; &lt;sqlMapGenerator targetPackage="com._520it.mybatis.mapper" targetProject="src/main/resources"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 targetPackage/targetProject:同javaModelGenerator type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）： 1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML； 2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中； 3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML； 注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER --&gt; &lt;javaClientGenerator targetPackage="com._520it.mybatis.mapper" type="ANNOTATEDMAPPER" targetProject="src/main/java"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查 &lt;property name="rootInterface" value=""/&gt; --&gt; &lt;/javaClientGenerator&gt; &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素 选择的table会生成一下文件： 1，SQL map文件 2，生成一个主键类； 3，除了BLOB和主键的其他字段的类； 4，包含BLOB的类； 5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选； 6，Mapper接口（可选） tableName（必要）：要生成对象的表名； 注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会 根据设置的schema，catalog或tablename去查询数据表，按照下面的流程： 1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询； 2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找； 3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找； 4，否则，使用指定的大小写格式查询； 另外的，如果在创建表的时候，使用的""把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名； 这个时候，请设置delimitIdentifiers="true"即可保留大小写格式； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写； --&gt; &lt;table tableName="userinfo" &gt; &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt; &lt;property name="constructorBased" value="false"/&gt; &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt; &lt;property name="ignoreQualifiersAtRuntime" value="false"/&gt; &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt; &lt;property name="modelOnly" value="false"/&gt; &lt;!-- 参考 javaModelGenerator 的 rootClass 属性 &lt;property name="rootClass" value=""/&gt; --&gt; &lt;!-- 参考javaClientGenerator 的 rootInterface 属性 &lt;property name="rootInterface" value=""/&gt; --&gt; &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog &lt;property name="runtimeCatalog" value=""/&gt; --&gt; &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema &lt;property name="runtimeSchema" value=""/&gt; --&gt; &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename &lt;property name="runtimeTableName" value=""/&gt; --&gt; &lt;!-- 注意，该属性只针对MyBatis3Simple有用； 如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件； --&gt; &lt;property name="selectAllOrderByClause" value="age desc,username asc"/&gt; &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt; &lt;property name="useActualColumnNames" value="false"/&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性 &lt;generatedKey column="" sqlStatement=""/&gt; --&gt; &lt;!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为"^CUST_"，并使用空白替换，那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； &lt;columnRenamingRule searchString="" replaceString=""/&gt; --&gt; &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性； column:要重新设置的列名； 注意，一个table元素中可以有多个columnOverride元素哈~ --&gt; &lt;columnOverride column="username"&gt; &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt; &lt;property name="property" value="userName"/&gt; &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名 &lt;property name="javaType" value=""/&gt; --&gt; &lt;!-- jdbcType用于指定该列的JDBC类型 &lt;property name="jdbcType" value=""/&gt; --&gt; &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler 只会生成类似：where id = #&#123;id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler&#125;的参数描述 &lt;property name="jdbcType" value=""/&gt; --&gt; &lt;!-- 参考table元素的delimitAllColumns配置，默认为false &lt;property name="delimitedColumnName" value=""/&gt; --&gt; &lt;/columnOverride&gt; &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 column:指定要忽略的列的名字； delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 注意，一个table元素中可以有多个ignoreColumn元素 &lt;ignoreColumn column="deptId" delimitedColumnName=""/&gt; --&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[红黑树红黑树的特点 每个节点是黑色或者红色。 根节点是黑色。 每个叶子节点是黑色（这里叶子节点是指为空（NIL或者NULL）的叶子节点） 如果一个节点是红色，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的红黑节点（这里指到叶子节点的路径）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2019%2F03%2F13%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序 冒泡排序 原理 比较两个相邻元素，将值大的元素交换至右端。 12345678910for (int i = 0;i &lt; arr.length;i++) &#123; // 外层控制循环次数 for(int j = 0;j&lt;arr.lenth-1-i;j++)&#123; //内层循环控制每一趟排序多少次 if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; 快速排序 原理 选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class QuickSort &#123; public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; //temp就是基准位 temp = arr[low]; while (i&lt;j) &#123; //先看右边，依次往左递减 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; //再看左边，依次往右递增 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; //如果满足条件则交换 if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high); &#125; public static void main(String[] args)&#123; int[] arr = &#123;10,7,2,4,7,62,3,4,2,1,8,9,19&#125;; quickSort(arr, 0, arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 其他算法 斐波那契 12345678910public static void main(String[] args)&#123; int n=10; int a = 1,b = 1,c = 0; for (int i = i; i &lt;= n -2;i++)&#123; c = a + b; a = b; b = c; System.out.println(c); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用SQL]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%B8%B8%E7%94%A8SQL%2F</url>
    <content type="text"><![CDATA[基础 创建数据库 1CREATE DATABASE db-name 删除数据库 1drop database dbname 备份sql server 12345--创建 备份数据的deviceUSE masterEXEC sp_addumpdevice 'disk','testBack','path'--开始备份BACKUP DATABASE pubs TO testBack 创建新表 1234create table tabname(col1 yupe1 [not null][primary key],col2 type2[not null],...)--根据已有的表创建新表：create table tab_new like tab_old --使用旧表创建新表create table tab_new as select col1,col2...from tab_odl definition only 列操作 123456789101112131415161718Alter table tabname add column col type-- 列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度--添加主键Alter table tabname add primary key(col)--删除主键Alter table tabname drop primary key(col)--创建索引create [unique] index idxname on tabname(col...)--删除索引drop index idxname--注：索引是不可更改的，想更改必须删除重新建--创建视图create view viewname as select statement--删除视图drop view viewname 几个简单的基本sql语句 12345678910111213141516171819202122--选择select * from table where 范围；--插入insert into table(field1,field2) values (value1,value2)--删除delete from table where 范围--更新update table set field1 = value1 where 范围--查找select * from table where field1 like '%value1%'--排序select * from table order by field1,field2 [desc]--总数select count as totalcount from table1--求和select sum(field1) as sumvaluue from table1--平均select avg(field) as avgvalue from table1--最大select max(field) as maxvalue from table1--最小select min(field) as minvalue from table1 几个高级查询运算词 1234567891011/*UNION运算符：通过组合其他两个结果表（列如TABLE1和TABLE2）并小区表中任何重复行而派生出一个结果表，当ALL随UNION一起使用时（即UNION ALL），不消除重复行，两种情况下，派生表的每一行不是来自TABLE1就是来自TABLE2EXCEPT运算符：EXCEPT运算符通过只包括在TABLE1和而不在TABLE2中的行并消除所有重复行而派生出一个结果表。当ALL随EXCEPT一起使用时，不消除重复行INTERSECTINTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 */ 使用外连接 123456left (outer) join:--左外链接：结果集既包括表的匹配行，也包括左连接表的所有行。right (outer) join:--右外链接：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。full/cross (outer) join:--全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录 分组：group by: 一张表，一旦分组完成后，查询后只能得到租相关的信息。 组相关的信息：（统计信息）count,sum,max,min,avg 在SQL Sever中分组时：不能以text,ntext,image类型的字段作为分组一句 在select统计函数中的字段,不能和普通的字段放在一起； 对数据库进行操作： 分离数据库：sp_detach_db;附加数据库: sp_attach_db后接表名，附加需要完整的路径名 修改数据库名称：sp_renamedb ‘o_name’,”n_name”;]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLSQL]]></title>
    <url>%2F2019%2F03%2F13%2FPLSQL%2F</url>
    <content type="text"><![CDATA[概念 PL/SQL是一种高级数据库程序设计语言，该语言专门用于在各种环境小多ORACLE数据库进行方法。由于该语言集成于数据库服务器种，所以PL/SQL代码可以对数据进行快速高效的处理。除此之外，可以在ORACLEW数据库的某些客户端工具中，使用PL/SQL语言也是该语言的一个特点 PL/SQL程序由三个块组成，即声明部分、执行部分、异常处理部分 DECLARE 声明部分：再次声明PL/SQL用到的变量，类型及游标， 以及局部的存储过程和函数 BEGIN 执行部分：过程及SQL语句，程序的主要部分 EXCEPTION 执行异常部分：错误处理 END； 其中，执行部分是必须的 基本语法记录类型把逻辑相关的数据作为一个单元存储起来，乘坐PL/SQL RECORD的域（FIELD），其作用是存放互不相同但逻辑相关的信息。 12345678910111213141516171819202122232425262728293031declare​ --声明一个记录类型​ type emp_record is record(​ v_sal employees.salary%type, // 变量​ v_email employees.email%type,​ v_hire_date date​ );​ --定义一个记录类型的成员变量​ v_emp_record emp_record;begin​ --sql语句的操作：select ... into ... from ... where​ select salary,email,hire_date into v_sal,v_email,v_hire_date from employees where employee_id = 100; --使用记录类型后上边查询语句的修改​ select salary,email,hire_date into v_emp_record from employees where employee_id = 100; ​ --打印​ dbms_output.put_line(v_sal||&apos;,&apos;||v_email&apos;,&apos;||v_hire_date); --使用记录类型后上边查询语句的修改 dbms_output.put_line(v_emp_record.v_sal||&apos;,&apos;||v_emp_record.email&apos;,&apos;||v_emp_record.hire_date)end; 流程控制IF表达式 12345678IF&lt;布尔表达式&gt;THEN PL/SQL 和SQL语句；ELSIF&lt;其他布尔表达式&gt;THEN 其他语句;ELSE 其他语句；END IF； -- ELSIF 不能携程 ELSEIF 例1 12345678910111213141516171819202122Declare v_empno employee.employee_id%TYPE :=&amp;empno; v_salary employee.salary%TYPE; v_comment VARCHAR2(35);Begin select salary INTO v_salary from employees where employee_id=v_empno; if v_salary &lt;1500 then v_comment:=&apos;太少了，加点吧~！&apos; elsif v_salary&lt;3000 then v_comment:=&apos;多了点，少点吧~！&apos; else v_comment:=&apos;没有薪水~！&apos; end if; DBMS_OUTPUT.PUT_LINE(v_comment); exception when no_data_found then DBMS_OUTPUT.PUT_LINE(&apos;没有数据~！&apos;)； when others then DBMS_OUTPUT.PUT_LINE(saqlcode||&apos;——&apos;||sqlerrm);END;注：Oracle内置函数sqlcode和sqlerrm主要用在others处理器中，分别用来返回oracle的错误代码和错误消息。 CASE表达式 123456789101112131415161718192021222324--格式一CASE 条件表达式 WHEN 条件表达式结果1 THEN 语句段1 WHEN 条件表达式结果2 THEN 语句段2 …… WHEN 条件表达式结果n THEN 语句段n [ELSE 条件表达式结果]END;--格式二CASE WHEN 条件表达式1 THEN 语句段1 WHEN 条件表达式2 THEN 语句段2 …… WHEN 条件表达式n THEN 语句段n [ELSE 语句段]END; 循环LOOP执行语句； EXIT WHEN &lt;条件语句&gt; END LOOP 12345678910例：Declare int NUMBER(2):=0;BEGIN LOOP int :=int+1 DBMS_OUTPUT.PUT_LINE(&apos;int的当前值：&apos;||int); EXIT WHEN int=10; END LOOP;END; WHILE循环WHILE&lt;布尔表达式&gt;LOOP ​ 要执行的语句； END LOOP； 123456789例：Declare x NUMBER(1):=1;BEGIN WHILE x&lt;10 LOOP DBMS_OUTPUT.PUT_LINE(&apos;X的当前值为：&apos;||x); x:=x+1; END LOOP;END; 数字式循环，For循环[&lt;&lt;循环标签&gt;&gt;] FOR 循环计数器 IN [REVERSE] 下限 .. 上限 LOOP ​ 要执行的语句； END LOOP [循环标签]; 注：没循环一次，循环变量自动加1；使用关键字REVERSE，循环变量自动鉴1.跟在IN REVERSE 后面的数字必须是从小到大的顺序，而且必须是整数，不能是变量或表达式。可以使用EXIT退出循环。 123456例1：BEGIN FOR int in 1..10 LOOP DBMS_OUTPUT.PUT_LINE(&apos;int的当前值为：&apos;||int); END LOOP;END; 12345678910111213141516例2：create table temp_table(num_col NUMBER);DECLARE V_counter NUMBER:=10;BEGIN INSERT INTO temp_table(num_col) VALUES (v_counter); FOR v_counter in 20..25 LOOP INSERT INTO temp_table(num_col) VALUES (v_counter); END LOOP; INSERT INTO temp_table(num_col) VALUES (v_counter); FOR v_counter IN REVERSE 20..25 LOOP INSERT INTO temp_table(num_col) VALUES (v_counter); END LOOP;END; DROP TABLE temp_table; 12345678910111213141516例3:DECLARE TYPE jobids_varray IS VARRAY(12) OF VARCHAR2(10); —定义一个VARRAY数据类型 v_jobids JOBIDS_VARRAY; —声明一个具有JOBIDS_VARRAY数据类型的变量 v_howmany NUMBER; —声明一个变量来保存雇员的数量BEGIN —用某些job_id值初始化数组 v_jobids := jobids_varray(‘FI_ACCOUNT‘, ‘FI_MGR‘, ‘ST_CLERK‘, ‘ST_MAN‘); —用FOR…LOOP…END LOOP循环使用每个数组成员的值 FOR i IN v_jobids.FIRST..v_jobids.LAST LOOP —针对数组中的每个岗位，决定该岗位的雇员的数量 SELECT count(*) INTO v_howmany FROM employees WHERE job_id = v_jobids(i); DBMS_OUTPUT.PUT_LINE ( ‘岗位‘||v_jobids(i)|| ‘总共有‘|| TO_CHAR(v_howmany) || ‘个雇员‘); END LOOP;END; 123456789101112131415161718192021222324252627例4: 在While循环中嵌套loop循环 /*求100至110之间的素数*/DECLARE v_m NUMBER := 101; v_i NUMBER; v_n NUMBER := 0;BEGIN WHILE v_m &lt; 110 LOOP v_i := 2; LOOP IF mod(v_m, v_i) = 0 THEN v_i := 0; EXIT; END IF; v_i := v_i + 1; EXIT WHEN v_i &gt; v_m – 1; END LOOP; IF v_i &gt; 0 THEN v_n := v_n + 1; DBMS_OUTPUT.PUT_LINE(‘第‘|| v_n || ‘个素数是‘ || v_m); END IF; v_m := v_m + 2; END LOOP;END; 标号和GOTOPL/SQL中GOTO语句是无条件跳转到指定的标号去的意思。语法如下： GOTO label ….. &lt;&gt; /标号是用&lt;&lt; &gt;&gt;括起来的标识符 / 注意，在以下地方使用是不合法的，编译时会出错误。 跳转到非执行语句前面。 跳转到子块中。 跳转到循环语句中。 跳转到条件语句中。 从异常处理部分跳转到执行。 从条件语句的一部分跳转到另一部分。 12345678910111213DECLARE V_counter NUMBER := 1;BEGIN LOOP DBMS_OUTPUT.PUT_LINE(‘V_counter的当前值为:‘||V_counter); V_counter := v_counter + 1; IF v_counter &gt; 10 THEN GOTO labelOffLOOP; END IF; END LOOP; &lt;&lt;labelOffLOOP&gt;&gt; DBMS_OUTPUT.PUT_LINE(‘V_counter的当前值为:‘||V_counter);END; 123456789101112DECLARE v_i NUMBER := 0; v_s NUMBER := 0;BEGIN &lt;&lt;label_1&gt;&gt; v_i := v_i + 1; IF v_i &lt;= 1000 THEN v_s := v_s + v_i; GOTO label_1; END IF; DBMS_OUTPUT.PUT_LINE(v_s);END; NULL语句在PL/SQL 程序中，NULL语句是一个可执行语句，可以用 null 语句来说明“不用做任何事情”的意思，相当于一个占位符或不执行任何操作的空语句，可以使某些语句变得有意义，提高程序的可读性，保证其他语句结构的完整性和正确性。如： 123456789101112例1：DECLARE …BEGIN … IF v_num IS NULL THEN GOTO labelPrint; END IF; … &lt;&lt;labelPrint&gt;&gt; NULL; —不需要处理任何数据。END; 123456789101112131415161718例2:DECLARE v_emp_id employees.employee_id%TYPE; v_first_name employees.first_name%TYPE; v_salary employees.salary%TYPE; v_sal_raise NUMBER(3,2);BEGIN v_emp_id := &amp;emp_id; SELECT first_name, salary INTO v_first_name, v_salary FROM employees WHERE employee_id = v_emp_id; IF v_salary &lt;= 3000 THEN v_sal_raise := .10; DBMS_OUTPUT.PUT_LINE(v_first_name||‘的工资是‘||v_salary ||‘、工资涨幅是‘||v_sal_raise); ELSE NULL; END IF;END; 游标的使用在PL/SQL程序中，对于处理多行记录的事务经常使用游标来实现。 类似于Java中的iterator。是一个指向上下文的句柄或指针。 显示游标处理需要四个PL/SQL处理步骤： 定义游标： CURSOR 打开游标 OPEN 提取游标数据：检索结果集合中的数据行，放入指定的输出变量中。 格式 FETCH cursor_name INTO {variable_list | record_variable}; 关闭游标： CLOSE cursor_name; 123456789101112declarecursor c is select tname from tab ; l_tname varchar2(64);begin open c ; loop fetch c into l_tname ; exit when c%notfound ; dbms_output.put_line(l_tname);end loop;close c;end; 12345678910111213141516171819202122232425--打印出80部门所有员工工资declare --声明一个记录类型 type emp_record is record( v_sal employees.salary%type, v_empid v_employees.employee_id%type ); --声明一个记录类型的变量 v_emp_record emp_record --定义一个游标 cursor emp_sal_cursor is select salary,employee_id from employees where department_id = 80;begin --打开游标 open emp_sal_cursor --提取游标 fetch emp_sal_cursor into v_emp_record; while emp_sal_cursor%found loop dbms_output_putline(&apos;salary:&apos;||v_emp_record.v_sal&apos;,&apos;||v_emp_record.v_emp); fetch emp_sal_cursor into v_sal,v_empid; end loop; --关闭游标 close emp_sal_cursor;end;]]></content>
      <categories>
        <category>PLSQL</category>
      </categories>
      <tags>
        <tag>PLSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux面试题]]></title>
    <url>%2F2019%2F03%2F12%2Flinux%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基础 zip的解压方式 zip -r /test/etc /test unzip /test/etc Linux内核引导时，从文件 /etc/fstab 中读取要加载的文件系统 Linux文件系统中每个文件用索引节点来标识。 vi编辑模式下，用ESC来进行模式转化 检查已安装的文件系统/dev/had5 是否正常，若检查有错则自动修复，其命令及参数是？ fsck -a /dev/had5 在Linux系统下，第二个IDE通道的硬盘(从盘)被标识为 hdb 为脚本程序 test.sh 指定执行权限的命令以及参数是 chmod a+x test.sh 或者 chmod 755 test.sh 如何让一个check.sh脚本从每天凌晨2点30分执行 30 02 /bin/bash /home/fang/check.sh 用一条命令实现删除当前目录下3天前被修改的文件 find ./ -type f -mtime +3 -exex rm -f {} \; 怎样查看当前系统版本 1cat /etc/CentOs-release]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[触发器的作用 触发器是一种特殊存储过程，主要通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作而不允许未经许可的更新和变化。可以联机运算。如，某表上的触发器包含对另一个表的数据操作，而该操作又会出发新的触发器。 什么是存储过程？用什么来调用 存储过程是一个预编译的Sql语句 Oracle常用名词、概念 数据库块（BLOCK） Oracle数据库中的最小存储和处理单位，包含块本身的头信息数据或PL/SQL代码， Oracle块的大小可以在安装时选择自定义安装来指定，也可以在CREATEDATABASE创建数据库实例时指定。最小为2K最大64K 瓶颈（Bottleneck） 指限制系统性能的部件 面向对象的关系数据库 具有关系数据库的全部功能同时又支持面向对象的数据库称作面向对象关系数据库系统 ，Oracle7是一种功能完备的关系数据库系统 DML：数据库操纵语言：它们是Select、update、insert、delete，就像它的名字一样，对数据库里面的数据进行操作 DDL：数据定义语言：DDL比DML要多，主要命令有CREATE、ALTER、DROP等，DDL主要用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，它们大多在建表时使用。 DCL：数据库控制语言：是用来设置或更改数据库用户或角色权限的语句 SQL语言16种基本命令 DDL命令：CREATE，ALTER，DROP，RENAME，TRUNCATE，COMMENT DML命令：SELECT，INSERT，UPDATE，DELETE，MERGE DCL命令：SAVEPOINT，ROLLBACK，COMMIT，GRANT，REVOKE]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载均衡]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[负载均衡负载均衡建立在现有网络结构之上，是由多台服务器以对称方式组成一个服务器集合，每台服务器享有等价的地位 ，都可以单独对外提供服务而无需其他服务器的辅助。它提供了一种廉价有效同名的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络诗句处理能力、提高网络的灵活性和可用性。 反向代理负载均衡普通代理方式是代理内部网络用户访问Internet上服务器的连接请求，客户端必须指定代理服务器，并将本来要直接发送到Internet上服务器的连接请求发送给代理服务器处理。反向代理（Reverse proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内网服务器，并将得到的结果返回给Internet上请求的客户端，此时代理服务器对外就表现为一个服务器。反向代理负载均衡技术是把将来自Internet上的连接请求以反向代理的方式动态地转发给内网上的堕胎服务器进行处理，从而达到负载均衡的目的]]></content>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算是啥?]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%BA%91%E8%AE%A1%E7%AE%97%E6%98%AF%E5%95%A5%2F</url>
    <content type="text"><![CDATA[云计算 按量计费的公有计算资源 可编程性]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud]]></title>
    <url>%2F2019%2F03%2F05%2Fspring-cloud%2F</url>
    <content type="text"><![CDATA[spring cloud:​ Spring Cloud Netflix: ​ 是对Netflix开发的一套分布式服务器框架封装，包括服务的发现和注册，负载均衡，断路器，REST客户端，请求路由等。 ​ Spring Cloud Eureka: ​ 是Spring Colud Netflix为服务套件中的一部分，基于Netflix Eureka做了二次封装，主要负责完成微服务架构中的服务治理功能。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; eureka服务端 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 加上注解 12@EnableEurekaServer // eureka 服务端@EnableFeignClien //开启feign客户端 服务提供者]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk11新特性]]></title>
    <url>%2F2019%2F03%2F05%2Fjdk11%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[JShell(java9开始支持) 交互性工具，让java也可以像脚本语言一样运行，进行快速测试 123456启动命令jshell退出命令/exit查看帮助/help 详情点击官方文档 Dynamic Class-File Constants类文件一种新添结构 Java 的类型文件格式将被扩展，支持一种新的常量格式： CONSTANT_Dynamic,CONSTANT_Dynamic会将创建委托给 bootstrap方法 其谬地是降低开发新形式的可实现类文件约束带来的成本和干扰 局部变量的类型推断(var”关键字”) 什么是局部变量类型推断？ 12var javastack = "javastack";System.out.println(javastack) 局部变量的类型推断就是左边的类型直接使用var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型。 在声明隐式类型的lambda表达式的形参时允许使用var 使用var的好处是在使用lambda表达式时给参数加上注解 (@Nonnull var x,@Nullable var y) -&gt; x.process(y)； 注意点 12var a; //这样不可以，无法推断//类的属性的数据类型不可以使用var， 集合中的一些增强API 1234567891011121314public void test()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aa"); System.out.println(list);&#125;//快捷方式List&lt;String&gt; list2 = List.of("aa","bb");list2.add("cc") // 不能添加元素//List&lt;String&gt; list3 = Arrays.asList("aa","bb","cc");list3.add("dd")； // 不能添加元素Set set = Set.of(1,2,3,4); //同理，不能添加元素Set&lt;Integer&gt; set = Set.of(100,50,100) // 重复元素抛出异常]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk8新特性]]></title>
    <url>%2F2019%2F03%2F05%2Fjdk8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[jdk8新特性lambda表达式Lambda表达式用于表示一个函数，所以它和函数一样，也拥有参数、返回值、函数体，但它没有函数名，所以Lambda表达式相当于一个匿名函数。语法如下： 1(Person person)—&gt;person.getAge()&gt;30 Lambda表达式用—&gt;连接，-&gt;左侧为函数的参数，-&gt;右侧为函数体。若右侧由多条语句构成则需要用{}包裹 为lambda表达式定义函数式接口1234@FunctionalInterfaceinterface FilterProcessor&lt;T&gt;&#123; boolean process(T t);&#125; 实现筛选函数 123456List&lt;T&gt; filter(List&lt;T&gt; list, FilterProcessor&lt;T&gt; filterProcessor)&#123; List&lt;T&gt; result = new ArrayList&lt;T&gt;(); if(filterProcessor.process(t)) result.add(t); return result;&#125; 方法引用函数式接口streamoptional类默认方法Java 8 新增了接口的默认方法 简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法 只需要在方法名前面加个default关键字即可实现默认方法 语法12345public interface Vehicle()&#123; defalut void print()&#123; System.out.println("这是一个默认方法") &#125;&#125; super调用指定接口的默认方法12345public class Car implements Vehicle, FourWheeler &#123; public void print()&#123; Vehicle.super.print(); &#125;&#125; 静态默认方法java8的另一个特性是接口可以声明（并且可以提供实现）静态方法 123456789public interface Vehicle &#123; default void print()&#123; System.out.println("我是一辆车!"); &#125; // 静态方法 static void blowHorn()&#123; System.out.println("按喇叭!!!"); &#125;&#125; 新的日期时间API本地化日期时间API12345678910111213LocalDateTime currentTime = LocalDateTime.now();LocalDate date1 = currentTime.toLocalDate();Month month = currentTime.getMonth();int day = currentTime.getDayOfMonth();int seconds = currentTime.getSecond();//date2: 2012-04-10T16:55:48.668LocalDate date2 = currentTime.withDayOfMonth(10).withYear(2012);//date3: 2014-12-12LocalDate date3 = LocalDate.of(2014,Month.DECEMBER,12);//date4: 22:15LocalTime date4 = localTime.of(22,15);//date5: 20:15:30 解析字符串LocalTime date5 = LocalTime.parse("20:15:30") 使用时区的日期时间API12345678//获取当前时间日期ZonedDateTime date1 = ZonedDateTime。parse("2015-12-03T10:15:30+05:30[Asia/Shanghai]");//ZoneId : Europe/ParisZoneId id = ZoneId.of("Europe/Paris");//当前失去 ： Asia/ShanghaiZoneId currentZone = ZoneId.systemDefault();]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[String和String Buffer以及String Builer的区别 线程安全：String和StringBuilder线程不安全，StringBuffer线程安全 效率：StringBuilder &gt; StringBuffcer 使用原则：当数据量小且单线程使用String，数据量大单线程使用StringBuilder。多线程使用StringBuffer List、Set、Map list: 可以允许重复对象 可以插入多个null元素 是一个有序容器，输出顺序即插入顺序 常用实现类ArrayList、LinkedList和Vector set: 不允许重复对象 只允许一个Null元素 无序容器，TreeSet通过Comparator或者Comparable维护了一个排序顺序 常用实现类HashSet、LinkedHashSet以及TreeSet。TreeSet实现了SortedSet接口 Map：不是collection的子接口或者实现类，Map是一个接口 Map的每个Entry都持有两个对象，键唯一 TreeMap Map里可以有多个Null值，但只有一个null键 ==与equals ==：作用是判断两个对象的地址是否相等 equals() 当类没有覆盖equals()方法，则通过equals()比较类的两个对象时，等价于通过”==”比较这两个对象 类覆盖equals()方法，则比较内容是否相等。 hashCode与equals hashCode()的作用是获取哈希码，返回int整数。在插入数据时先比较hash值，如果相同会调用equals()比较内容是否相同，如果相同则不加入，如果不同则重新散列到其他位置。就减少了equals的次数，提高执行速度。 hashCode与equals的相关规定 如果两个对象相等，则hashCode一定相同 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同哈希值，它们不一定相同 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 什么是多态？ 多态是同一个行为具有多个不同表现形式或形态 多态就是同一个接口，使用不同的实例而执行不同的操作 编译时多态和运行时多态 编译时多态 主要是方法的重载，通过参数列表的不同来区分不同的方法。 运行时多态 也称作动态绑定，一般是指在执行期间判断段引用对象的实际类型，根据实际类型判断并调用相应的属性和方法。主要用于继承父类和实现接口时，父类引用指向子类对象。 int和integer的区别 int是基本数据类型，integer是其包装类 integer必须实例化后猜能使用，int则不需要 integer是实际对象的引用，当new一个integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 integer的默认值是null，int是0 抽象类和接口有什么异同 抽象类可以有默认的方法实现，接口则完全抽象，需要default关键字 都需要子类实现声明的方法 抽象类可以有构造器，接口不可以 接口方法只能用public修饰符，抽象方法可以使用private以外的修饰符 抽象类可以继承一个类和实现多个接口，接口只可以继承一个或多个其他接口 什么是死锁？如何避免死锁 定义 线程死锁是指由两个或者多个线程互相持有对方所需要的资源，导致线程处于等待状态 递归死锁 本函数调用其他函数，其他函数又调用本函数 避免死锁 加锁顺序 加锁时限 死锁检测 什么是ORM 对象关系映射 将对象和数据库中的数据进行绑定 mybatis中#和$占位符的区别 #将传入的数据当成字符串，会对自动传入的数据加双引号 $将传入的数据直接显示生成在sql中 #能防止sql注入 $方式一般用于传入数据库对象，例如传入表明 一般能用#不用$ 写一个Singleton实例 12345678910111213141516/* 某个类只能有一个实例 构造器私有化 它必须自行创建这个实例 含有一个该类的静态变量来保存这个实例 它必须自行向整个系统提供这个实例 对外提供获取该实例对象的方式 枚举式 将该类型对象限定为一个*/public enum Singleton&#123; public static final Singleton instance = new Singleton(); private Singleton()&#123; &#125;&#125; 类初始化过程 一个类要创建实例需要先加载并初始化该类 main方法所在的类需要先加载和被初始化 子类需要先初始化父类 类的初始化就是执行()方法 在字节码文件中 ()方法由静态类变量显示赋值代码和静态代码块组成 类变量显示赋值代码和静态代码块代码从上到下顺序执行 ()方法只执行一次 实例初始化过程 实例初始化就是执行()方法 ()方法可能重载多个，有几个构造器就有几个()方法 ()方法由非静态实例变量显示赋值代码块和非静态代码块、对应构造器代码组成 非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器代码最后执行 每次创建实例对象，调用对应构造器，执行的就是对应的()方法 ()方法的首行是super（）或者super(实参列表)，即对应父类的()方法 spring bean的作用域 在Spring中，可以在元素的scope属性里设置bean的作用域，以决定这个bean是单实例的还是多实例的。 默认情况下，Spring只为在每个IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例：所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被成为Singleton，它是所有bean的默认作用域。 prototype 每次调用getBean()时都会返回一个新的实例 request 每次HTTP请求会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP session共享一个Bean，不同的HTTP session使用不同的Bean。该作用域仅适用于WebApplicaitionContext环境 简单介绍Spring支持的常用数据库事务传播属性和事务隔离级别 事务的属性 propagation：用来设置事务的传播行为 事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务。 -Propagation.REQUIRED:默认值：使用原来的事务 -Propagation.REQUIRED_NEW：将原来的事务挂起，开启一个新的事务 isolation：用来设置事务的隔离级别 -Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别 -Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，开发时通常使用的隔离级别]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap实现原理]]></title>
    <url>%2F2019%2F03%2F04%2FHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[HashMap实现原理：jdk1.8以前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 哈希表（散列表）：在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)；哈希表的主干是数组； 哈希冲突：当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式 HashMap的主干是一个Entry数组，Entry是Hash Map的基本组成单元，每一个Entry包含一个key-value键值对。 Entry是HashMap中的一个静态内部类。代码如下： 123456789101112131415static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构 int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算 /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; 其他几个重要字段12345678//实际存储的key-value键值对的个数transient int size;//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount; jdk1.8之后源码 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树是一种平衡二叉树，为了解决二叉树的缺陷，因为二叉树查找某些情况下会退化成为一个线性结构 为什么不直接使用红黑树我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡。引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。 HashMap构造器HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值 initialCapacity默认为16，loadFactory默认为0.75 数据结构的物理存储结构只有两种：顺序存储和链式存储。 源码12345678public HashMap(int initialCapacity) &#123; /** * The load factor used when none specified in constructor. * static final float DEFAULT_LOAD_FACTOR = 0.75f; 装填因子，在数组长度的0.75的时候扩容 * final float loadFactor 接收装填因子的变量 */ this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; HashMap和HashTable的区别/HashSet和HashMap的区别Hash Map和HashTable 线程安全：HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法都通过synchronized修饰（如果要保证线程安全使用ConcurrentHashMap） 效率：HashMap效率高，因为HashTable需要保证线程安全 对Null Key和Null Value 的支持：HashMap中,null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为Null，HashTable只要有一个键为Null，就抛出空指针异常 ①初始容量大小和每次扩容增量不同：HashTable默认为11，每次扩容变为 原来的2n+1，HashMap默认初始化大小为16，之后每次扩容容量变为原来的2倍。②如果创建的时候给定了初始容量值，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tableSizeFor（）方法保证），也就是说Hash Map总是使用2的幂次方作为哈希表的大小。 底层数据结构：红黑树和链表散列的区别 HashSet和HashMap如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。） HashMap HashSet 实现了Map接口 实现Set接口 存储键值对 仅存储对象 调用put()向map中添加元素 调用add()方法向Set中添加元素 HashMap使用key计算HashCode HashSet使用成员对象来计算HashCode，对于两个对象来说hashCode可能相同，所以equals()方法来判断对象的相等性，如果两个对象不相同的话，返回false HashMap相对于HashSet来说较快，因为它使用唯一的键获取对象 较慢]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
